// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/lingticio/gateway/internal/graph/openai/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	ChatCompletionArrayContent struct {
		Parts func(childComplexity int) int
	}

	ChatCompletionAssistantMessage struct {
		Content    func(childComplexity int) int
		Name       func(childComplexity int) int
		Role       func(childComplexity int) int
		ToolCallID func(childComplexity int) int
		ToolCalls  func(childComplexity int) int
	}

	ChatCompletionChoice struct {
		FinishReason func(childComplexity int) int
		Index        func(childComplexity int) int
		Logprobs     func(childComplexity int) int
		Message      func(childComplexity int) int
	}

	ChatCompletionContentPartImage struct {
		ImageURL func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	ChatCompletionContentPartImageURL struct {
		Detail func(childComplexity int) int
		URL    func(childComplexity int) int
	}

	ChatCompletionContentPartText struct {
		Text func(childComplexity int) int
		Type func(childComplexity int) int
	}

	ChatCompletionMessageToolCall struct {
		Function func(childComplexity int) int
		ID       func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	ChatCompletionMessageToolCallChunk struct {
		Function func(childComplexity int) int
		ID       func(childComplexity int) int
		Index    func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	ChatCompletionResult struct {
		Choices           func(childComplexity int) int
		Created           func(childComplexity int) int
		ID                func(childComplexity int) int
		Model             func(childComplexity int) int
		Object            func(childComplexity int) int
		SystemFingerprint func(childComplexity int) int
		Usage             func(childComplexity int) int
	}

	ChatCompletionStreamChunkChoice struct {
		Delta        func(childComplexity int) int
		FinishReason func(childComplexity int) int
		Index        func(childComplexity int) int
	}

	ChatCompletionStreamResponseDelta struct {
		Content      func(childComplexity int) int
		FunctionCall func(childComplexity int) int
		Role         func(childComplexity int) int
		ToolCalls    func(childComplexity int) int
	}

	ChatCompletionStreamResult struct {
		Choices           func(childComplexity int) int
		Created           func(childComplexity int) int
		ID                func(childComplexity int) int
		Model             func(childComplexity int) int
		Object            func(childComplexity int) int
		SystemFingerprint func(childComplexity int) int
		Usage             func(childComplexity int) int
	}

	ChatCompletionSystemMessage struct {
		Content func(childComplexity int) int
		Name    func(childComplexity int) int
		Role    func(childComplexity int) int
	}

	ChatCompletionTextContent struct {
		Text func(childComplexity int) int
	}

	ChatCompletionToolMessage struct {
		Content    func(childComplexity int) int
		Name       func(childComplexity int) int
		Role       func(childComplexity int) int
		ToolCallID func(childComplexity int) int
	}

	ChatCompletionUserMessage struct {
		Content func(childComplexity int) int
		Name    func(childComplexity int) int
		Role    func(childComplexity int) int
	}

	FunctionCall struct {
		Arguments func(childComplexity int) int
		Name      func(childComplexity int) int
	}

	FunctionCallChunk struct {
		Arguments func(childComplexity int) int
		Name      func(childComplexity int) int
	}

	LogProbs struct {
		Content func(childComplexity int) int
		Refusal func(childComplexity int) int
	}

	Model struct {
		Name func(childComplexity int) int
	}

	ModelConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ModelEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		CreateChatCompletion func(childComplexity int, input model.CreateChatCompletionInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Models func(childComplexity int, first *int, after *string, last *int, before *string) int
	}

	Subscription struct {
		CreateChatCompletionStream func(childComplexity int, input model.CreateChatCompletionInput) int
	}

	TokenLogProb struct {
		Bytes       func(childComplexity int) int
		LogProb     func(childComplexity int) int
		Token       func(childComplexity int) int
		TopLogProbs func(childComplexity int) int
	}

	TopLogProb struct {
		Bytes   func(childComplexity int) int
		LogProb func(childComplexity int) int
		Token   func(childComplexity int) int
	}

	Usage struct {
		CompletionTokens func(childComplexity int) int
		PromptTokens     func(childComplexity int) int
		TotalTokens      func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateChatCompletion(ctx context.Context, input model.CreateChatCompletionInput) (*model.ChatCompletionResult, error)
}
type QueryResolver interface {
	Models(ctx context.Context, first *int, after *string, last *int, before *string) (*model.ModelConnection, error)
}
type SubscriptionResolver interface {
	CreateChatCompletionStream(ctx context.Context, input model.CreateChatCompletionInput) (<-chan *model.ChatCompletionStreamResult, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "ChatCompletionArrayContent.parts":
		if e.complexity.ChatCompletionArrayContent.Parts == nil {
			break
		}

		return e.complexity.ChatCompletionArrayContent.Parts(childComplexity), true

	case "ChatCompletionAssistantMessage.content":
		if e.complexity.ChatCompletionAssistantMessage.Content == nil {
			break
		}

		return e.complexity.ChatCompletionAssistantMessage.Content(childComplexity), true

	case "ChatCompletionAssistantMessage.name":
		if e.complexity.ChatCompletionAssistantMessage.Name == nil {
			break
		}

		return e.complexity.ChatCompletionAssistantMessage.Name(childComplexity), true

	case "ChatCompletionAssistantMessage.role":
		if e.complexity.ChatCompletionAssistantMessage.Role == nil {
			break
		}

		return e.complexity.ChatCompletionAssistantMessage.Role(childComplexity), true

	case "ChatCompletionAssistantMessage.toolCallId":
		if e.complexity.ChatCompletionAssistantMessage.ToolCallID == nil {
			break
		}

		return e.complexity.ChatCompletionAssistantMessage.ToolCallID(childComplexity), true

	case "ChatCompletionAssistantMessage.toolCalls":
		if e.complexity.ChatCompletionAssistantMessage.ToolCalls == nil {
			break
		}

		return e.complexity.ChatCompletionAssistantMessage.ToolCalls(childComplexity), true

	case "ChatCompletionChoice.finishReason":
		if e.complexity.ChatCompletionChoice.FinishReason == nil {
			break
		}

		return e.complexity.ChatCompletionChoice.FinishReason(childComplexity), true

	case "ChatCompletionChoice.index":
		if e.complexity.ChatCompletionChoice.Index == nil {
			break
		}

		return e.complexity.ChatCompletionChoice.Index(childComplexity), true

	case "ChatCompletionChoice.logprobs":
		if e.complexity.ChatCompletionChoice.Logprobs == nil {
			break
		}

		return e.complexity.ChatCompletionChoice.Logprobs(childComplexity), true

	case "ChatCompletionChoice.message":
		if e.complexity.ChatCompletionChoice.Message == nil {
			break
		}

		return e.complexity.ChatCompletionChoice.Message(childComplexity), true

	case "ChatCompletionContentPartImage.imageUrl":
		if e.complexity.ChatCompletionContentPartImage.ImageURL == nil {
			break
		}

		return e.complexity.ChatCompletionContentPartImage.ImageURL(childComplexity), true

	case "ChatCompletionContentPartImage.type":
		if e.complexity.ChatCompletionContentPartImage.Type == nil {
			break
		}

		return e.complexity.ChatCompletionContentPartImage.Type(childComplexity), true

	case "ChatCompletionContentPartImageURL.detail":
		if e.complexity.ChatCompletionContentPartImageURL.Detail == nil {
			break
		}

		return e.complexity.ChatCompletionContentPartImageURL.Detail(childComplexity), true

	case "ChatCompletionContentPartImageURL.url":
		if e.complexity.ChatCompletionContentPartImageURL.URL == nil {
			break
		}

		return e.complexity.ChatCompletionContentPartImageURL.URL(childComplexity), true

	case "ChatCompletionContentPartText.text":
		if e.complexity.ChatCompletionContentPartText.Text == nil {
			break
		}

		return e.complexity.ChatCompletionContentPartText.Text(childComplexity), true

	case "ChatCompletionContentPartText.type":
		if e.complexity.ChatCompletionContentPartText.Type == nil {
			break
		}

		return e.complexity.ChatCompletionContentPartText.Type(childComplexity), true

	case "ChatCompletionMessageToolCall.function":
		if e.complexity.ChatCompletionMessageToolCall.Function == nil {
			break
		}

		return e.complexity.ChatCompletionMessageToolCall.Function(childComplexity), true

	case "ChatCompletionMessageToolCall.id":
		if e.complexity.ChatCompletionMessageToolCall.ID == nil {
			break
		}

		return e.complexity.ChatCompletionMessageToolCall.ID(childComplexity), true

	case "ChatCompletionMessageToolCall.type":
		if e.complexity.ChatCompletionMessageToolCall.Type == nil {
			break
		}

		return e.complexity.ChatCompletionMessageToolCall.Type(childComplexity), true

	case "ChatCompletionMessageToolCallChunk.function":
		if e.complexity.ChatCompletionMessageToolCallChunk.Function == nil {
			break
		}

		return e.complexity.ChatCompletionMessageToolCallChunk.Function(childComplexity), true

	case "ChatCompletionMessageToolCallChunk.id":
		if e.complexity.ChatCompletionMessageToolCallChunk.ID == nil {
			break
		}

		return e.complexity.ChatCompletionMessageToolCallChunk.ID(childComplexity), true

	case "ChatCompletionMessageToolCallChunk.index":
		if e.complexity.ChatCompletionMessageToolCallChunk.Index == nil {
			break
		}

		return e.complexity.ChatCompletionMessageToolCallChunk.Index(childComplexity), true

	case "ChatCompletionMessageToolCallChunk.type":
		if e.complexity.ChatCompletionMessageToolCallChunk.Type == nil {
			break
		}

		return e.complexity.ChatCompletionMessageToolCallChunk.Type(childComplexity), true

	case "ChatCompletionResult.choices":
		if e.complexity.ChatCompletionResult.Choices == nil {
			break
		}

		return e.complexity.ChatCompletionResult.Choices(childComplexity), true

	case "ChatCompletionResult.created":
		if e.complexity.ChatCompletionResult.Created == nil {
			break
		}

		return e.complexity.ChatCompletionResult.Created(childComplexity), true

	case "ChatCompletionResult.id":
		if e.complexity.ChatCompletionResult.ID == nil {
			break
		}

		return e.complexity.ChatCompletionResult.ID(childComplexity), true

	case "ChatCompletionResult.model":
		if e.complexity.ChatCompletionResult.Model == nil {
			break
		}

		return e.complexity.ChatCompletionResult.Model(childComplexity), true

	case "ChatCompletionResult.object":
		if e.complexity.ChatCompletionResult.Object == nil {
			break
		}

		return e.complexity.ChatCompletionResult.Object(childComplexity), true

	case "ChatCompletionResult.systemFingerprint":
		if e.complexity.ChatCompletionResult.SystemFingerprint == nil {
			break
		}

		return e.complexity.ChatCompletionResult.SystemFingerprint(childComplexity), true

	case "ChatCompletionResult.usage":
		if e.complexity.ChatCompletionResult.Usage == nil {
			break
		}

		return e.complexity.ChatCompletionResult.Usage(childComplexity), true

	case "ChatCompletionStreamChunkChoice.delta":
		if e.complexity.ChatCompletionStreamChunkChoice.Delta == nil {
			break
		}

		return e.complexity.ChatCompletionStreamChunkChoice.Delta(childComplexity), true

	case "ChatCompletionStreamChunkChoice.finishReason":
		if e.complexity.ChatCompletionStreamChunkChoice.FinishReason == nil {
			break
		}

		return e.complexity.ChatCompletionStreamChunkChoice.FinishReason(childComplexity), true

	case "ChatCompletionStreamChunkChoice.index":
		if e.complexity.ChatCompletionStreamChunkChoice.Index == nil {
			break
		}

		return e.complexity.ChatCompletionStreamChunkChoice.Index(childComplexity), true

	case "ChatCompletionStreamResponseDelta.content":
		if e.complexity.ChatCompletionStreamResponseDelta.Content == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResponseDelta.Content(childComplexity), true

	case "ChatCompletionStreamResponseDelta.functionCall":
		if e.complexity.ChatCompletionStreamResponseDelta.FunctionCall == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResponseDelta.FunctionCall(childComplexity), true

	case "ChatCompletionStreamResponseDelta.role":
		if e.complexity.ChatCompletionStreamResponseDelta.Role == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResponseDelta.Role(childComplexity), true

	case "ChatCompletionStreamResponseDelta.toolCalls":
		if e.complexity.ChatCompletionStreamResponseDelta.ToolCalls == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResponseDelta.ToolCalls(childComplexity), true

	case "ChatCompletionStreamResult.choices":
		if e.complexity.ChatCompletionStreamResult.Choices == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResult.Choices(childComplexity), true

	case "ChatCompletionStreamResult.created":
		if e.complexity.ChatCompletionStreamResult.Created == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResult.Created(childComplexity), true

	case "ChatCompletionStreamResult.id":
		if e.complexity.ChatCompletionStreamResult.ID == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResult.ID(childComplexity), true

	case "ChatCompletionStreamResult.model":
		if e.complexity.ChatCompletionStreamResult.Model == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResult.Model(childComplexity), true

	case "ChatCompletionStreamResult.object":
		if e.complexity.ChatCompletionStreamResult.Object == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResult.Object(childComplexity), true

	case "ChatCompletionStreamResult.systemFingerprint":
		if e.complexity.ChatCompletionStreamResult.SystemFingerprint == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResult.SystemFingerprint(childComplexity), true

	case "ChatCompletionStreamResult.usage":
		if e.complexity.ChatCompletionStreamResult.Usage == nil {
			break
		}

		return e.complexity.ChatCompletionStreamResult.Usage(childComplexity), true

	case "ChatCompletionSystemMessage.content":
		if e.complexity.ChatCompletionSystemMessage.Content == nil {
			break
		}

		return e.complexity.ChatCompletionSystemMessage.Content(childComplexity), true

	case "ChatCompletionSystemMessage.name":
		if e.complexity.ChatCompletionSystemMessage.Name == nil {
			break
		}

		return e.complexity.ChatCompletionSystemMessage.Name(childComplexity), true

	case "ChatCompletionSystemMessage.role":
		if e.complexity.ChatCompletionSystemMessage.Role == nil {
			break
		}

		return e.complexity.ChatCompletionSystemMessage.Role(childComplexity), true

	case "ChatCompletionTextContent.text":
		if e.complexity.ChatCompletionTextContent.Text == nil {
			break
		}

		return e.complexity.ChatCompletionTextContent.Text(childComplexity), true

	case "ChatCompletionToolMessage.content":
		if e.complexity.ChatCompletionToolMessage.Content == nil {
			break
		}

		return e.complexity.ChatCompletionToolMessage.Content(childComplexity), true

	case "ChatCompletionToolMessage.name":
		if e.complexity.ChatCompletionToolMessage.Name == nil {
			break
		}

		return e.complexity.ChatCompletionToolMessage.Name(childComplexity), true

	case "ChatCompletionToolMessage.role":
		if e.complexity.ChatCompletionToolMessage.Role == nil {
			break
		}

		return e.complexity.ChatCompletionToolMessage.Role(childComplexity), true

	case "ChatCompletionToolMessage.toolCallId":
		if e.complexity.ChatCompletionToolMessage.ToolCallID == nil {
			break
		}

		return e.complexity.ChatCompletionToolMessage.ToolCallID(childComplexity), true

	case "ChatCompletionUserMessage.content":
		if e.complexity.ChatCompletionUserMessage.Content == nil {
			break
		}

		return e.complexity.ChatCompletionUserMessage.Content(childComplexity), true

	case "ChatCompletionUserMessage.name":
		if e.complexity.ChatCompletionUserMessage.Name == nil {
			break
		}

		return e.complexity.ChatCompletionUserMessage.Name(childComplexity), true

	case "ChatCompletionUserMessage.role":
		if e.complexity.ChatCompletionUserMessage.Role == nil {
			break
		}

		return e.complexity.ChatCompletionUserMessage.Role(childComplexity), true

	case "FunctionCall.arguments":
		if e.complexity.FunctionCall.Arguments == nil {
			break
		}

		return e.complexity.FunctionCall.Arguments(childComplexity), true

	case "FunctionCall.name":
		if e.complexity.FunctionCall.Name == nil {
			break
		}

		return e.complexity.FunctionCall.Name(childComplexity), true

	case "FunctionCallChunk.arguments":
		if e.complexity.FunctionCallChunk.Arguments == nil {
			break
		}

		return e.complexity.FunctionCallChunk.Arguments(childComplexity), true

	case "FunctionCallChunk.name":
		if e.complexity.FunctionCallChunk.Name == nil {
			break
		}

		return e.complexity.FunctionCallChunk.Name(childComplexity), true

	case "LogProbs.content":
		if e.complexity.LogProbs.Content == nil {
			break
		}

		return e.complexity.LogProbs.Content(childComplexity), true

	case "LogProbs.refusal":
		if e.complexity.LogProbs.Refusal == nil {
			break
		}

		return e.complexity.LogProbs.Refusal(childComplexity), true

	case "Model.name":
		if e.complexity.Model.Name == nil {
			break
		}

		return e.complexity.Model.Name(childComplexity), true

	case "ModelConnection.edges":
		if e.complexity.ModelConnection.Edges == nil {
			break
		}

		return e.complexity.ModelConnection.Edges(childComplexity), true

	case "ModelConnection.pageInfo":
		if e.complexity.ModelConnection.PageInfo == nil {
			break
		}

		return e.complexity.ModelConnection.PageInfo(childComplexity), true

	case "ModelEdge.cursor":
		if e.complexity.ModelEdge.Cursor == nil {
			break
		}

		return e.complexity.ModelEdge.Cursor(childComplexity), true

	case "ModelEdge.node":
		if e.complexity.ModelEdge.Node == nil {
			break
		}

		return e.complexity.ModelEdge.Node(childComplexity), true

	case "Mutation.createChatCompletion":
		if e.complexity.Mutation.CreateChatCompletion == nil {
			break
		}

		args, err := ec.field_Mutation_createChatCompletion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateChatCompletion(childComplexity, args["input"].(model.CreateChatCompletionInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.models":
		if e.complexity.Query.Models == nil {
			break
		}

		args, err := ec.field_Query_models_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Models(childComplexity, args["first"].(*int), args["after"].(*string), args["last"].(*int), args["before"].(*string)), true

	case "Subscription.createChatCompletionStream":
		if e.complexity.Subscription.CreateChatCompletionStream == nil {
			break
		}

		args, err := ec.field_Subscription_createChatCompletionStream_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.CreateChatCompletionStream(childComplexity, args["input"].(model.CreateChatCompletionInput)), true

	case "TokenLogProb.bytes":
		if e.complexity.TokenLogProb.Bytes == nil {
			break
		}

		return e.complexity.TokenLogProb.Bytes(childComplexity), true

	case "TokenLogProb.logProb":
		if e.complexity.TokenLogProb.LogProb == nil {
			break
		}

		return e.complexity.TokenLogProb.LogProb(childComplexity), true

	case "TokenLogProb.token":
		if e.complexity.TokenLogProb.Token == nil {
			break
		}

		return e.complexity.TokenLogProb.Token(childComplexity), true

	case "TokenLogProb.topLogProbs":
		if e.complexity.TokenLogProb.TopLogProbs == nil {
			break
		}

		return e.complexity.TokenLogProb.TopLogProbs(childComplexity), true

	case "TopLogProb.bytes":
		if e.complexity.TopLogProb.Bytes == nil {
			break
		}

		return e.complexity.TopLogProb.Bytes(childComplexity), true

	case "TopLogProb.logProb":
		if e.complexity.TopLogProb.LogProb == nil {
			break
		}

		return e.complexity.TopLogProb.LogProb(childComplexity), true

	case "TopLogProb.token":
		if e.complexity.TopLogProb.Token == nil {
			break
		}

		return e.complexity.TopLogProb.Token(childComplexity), true

	case "Usage.completionTokens":
		if e.complexity.Usage.CompletionTokens == nil {
			break
		}

		return e.complexity.Usage.CompletionTokens(childComplexity), true

	case "Usage.promptTokens":
		if e.complexity.Usage.PromptTokens == nil {
			break
		}

		return e.complexity.Usage.PromptTokens(childComplexity), true

	case "Usage.totalTokens":
		if e.complexity.Usage.TotalTokens == nil {
			break
		}

		return e.complexity.Usage.TotalTokens(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputChatCompletionContentPartImageURLInput,
		ec.unmarshalInputChatCompletionMessageContentPartInput,
		ec.unmarshalInputChatCompletionMessageInput,
		ec.unmarshalInputChatCompletionMessageToolCallInput,
		ec.unmarshalInputChatCompletionTool,
		ec.unmarshalInputChatCompletionToolFunction,
		ec.unmarshalInputCreateChatCompletionInput,
		ec.unmarshalInputCreateChatCompletionStreamOptions,
		ec.unmarshalInputFunctionCallInput,
		ec.unmarshalInputJSONSchemaInput,
		ec.unmarshalInputResponseFormatInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../../graph/openai/chat.graphqls", Input: `scalar Map

type ChatCompletionResult {
  """
  A unique identifier for the chat completion.
  """
  id: ID!
  """
  The object type, which is always "chat.completion".
  """
  object: String!
  """
  The Unix timestamp (in seconds) of when the chat completion was created.
  """
  created: Int!
  """
  The model used for the chat completion.
  """
  model: String!
  """
  A list of chat completion choices. Can be more than one if n is greater than 1.
  """
  choices: [ChatCompletionChoice!]!
  """
  Usage statistics for the completion request.
  """
  usage: Usage!
  """
  This fingerprint represents the backend configuration that the model runs with.
  Can be used in conjunction with the ` + "`" + `seed` + "`" + ` request parameter to understand when backend changes have been made that might impact determinism.
  """
  systemFingerprint: String
}

type ChatCompletionChoice {
  """
  The index of the choice in the list of choices.
  """
  index: Int!
  """
  The chat completion message generated by the model.
  """
  message: ChatCompletionMessage!
  """
  The reason the model stopped generating tokens. This will be "stop" if the model hit a natural stop point or a provided stop sequence,
  - "length" if the maximum number of tokens specified in the request was reached,
  - "content_filter" if content was omitted due to a flag from our content filters,
  - "tool_calls" if the model called a tool, or "function_call" (deprecated) if the model called a function.
  """
  finishReason: FinishReason
  """
  Log probability information for the choice.
  """
  logprobs: LogProbs
}

union ChatCompletionMessageContent = ChatCompletionTextContent | ChatCompletionArrayContent

type ChatCompletionTextContent {
  text: String!
}

"""
The contents of a chat completion message part
"""
union ChatCompletionMessageContentPart = ChatCompletionContentPartText | ChatCompletionContentPartImage

"""
Text content part of a chat completion message
"""
type ChatCompletionContentPartText {
  """
  The text content.
  """
  text: String!

  """
  The type of the content part.
  """
  type: String!
}

"""
Image content part of a chat completion message
"""
type ChatCompletionContentPartImage {
  """
  The image URL information.
  """
  imageUrl: ChatCompletionContentPartImageURL!

  """
  The type of the content part.
  """
  type: String!
}

"""
Image URL information for an image content part
"""
type ChatCompletionContentPartImageURL {
  """
  Either a URL of the image or the base64 encoded image data.
  """
  url: String!

  """
  Specifies the detail level of the image. Learn more in the
  [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
  """
  detail: ImageDetail
}

enum ImageDetail {
  auto
  low
  high
}

type ChatCompletionArrayContent {
  parts: [ChatCompletionMessageContentPart!]!
}

interface ChatCompletionMessage {
  role: String!
  content: ChatCompletionMessageContent
  name: String
}

type ChatCompletionSystemMessage implements ChatCompletionMessage {
  """
  The role of the messages author, in this case ` + "`" + `system` + "`" + `.
  """
  role: String!
  """
  The contents of the system message.
  """
  content: ChatCompletionMessageContent!
  """
  An optional name for the participant. Provides the model information to
  differentiate between participants of the same role.
  """
  name: String
}

type ChatCompletionUserMessage implements ChatCompletionMessage {
  """
  The role of the messages author, in this case ` + "`" + `user` + "`" + `.
  """
  role: String!
  """
  The contents of the user message.
  """
  content: ChatCompletionMessageContent!
  """
  An optional name for the participant. Provides the model information to
  differentiate between participants of the same role.
  """
  name: String
}

type ChatCompletionAssistantMessage implements ChatCompletionMessage {
  """
  The role of the messages author, in this case ` + "`" + `assistant` + "`" + `.
  """
  role: String!
  """
  The contents of the assistant message. Required unless ` + "`" + `toolCalls` + "`" + ` is specified.
  """
  content: ChatCompletionMessageContent
  """
  An optional name for the participant. Provides the model information to
  differentiate between participants of the same role.
  """
  name: String
  """
  The tool calls generated by the model, such as function calls.
  """
  toolCalls: [ChatCompletionMessageToolCall!]
  """
  The ID of the tool call that this message is responding to.
  """
  toolCallId: String
}

type ChatCompletionToolMessage implements ChatCompletionMessage {
  """
  The role of the messages author, in this case ` + "`" + `tool` + "`" + `.
  """
  role: String!
  """
  The contents of the tool message.
  """
  content: ChatCompletionMessageContent!
  """
  An optional name for the participant. Provides the model information to
  differentiate between participants of the same role.
  """
  name: String
  """
  Tool call that this message is responding to.
  """
  toolCallId: String!
}

type ChatCompletionMessageToolCall {
  """
  The ID of the tool call.
  """
  id: String!

  """
  The function that the model called.
  """
  function: FunctionCall!

  """
  The type of the tool. Currently, only ` + "`" + `function` + "`" + ` is supported.
  """
  type: String!
}

type FunctionCall {
  """
  The name of the function to call.
  """
  name: String!
  """
  The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  """
  arguments: String!
}

type Usage {
  """
  Number of tokens in the prompt.
  """
  promptTokens: Int!
  """
  Number of tokens in the generated completion.
  """
  completionTokens: Int!
  """
  Total number of tokens used in the request (prompt + completion).
  """
  totalTokens: Int!
}

type LogProbs {
  """
  A list of message content tokens with log probability information.
  """
  content: [TokenLogProb!]!
  """
  A list of message refusal tokens with log probability information.
  """
  refusal: [TokenLogProb!]!
}

type TokenLogProb {
  """
  The token.
  """
  token: String!
  """
  The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value ` + "`" + `-9999.0` + "`" + ` is used to signify that the token is very unlikely.
  """
  logProb: Float!
  """
  A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be ` + "`" + `null` + "`" + ` if there is no bytes representation for the token.
  """
  bytes: [Int!]!
  """
  List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested ` + "`" + `top_logprobs` + "`" + ` returned.
  """
  topLogProbs: [TopLogProb!]!
}

type TopLogProb {
  """
  The token.
  """
  token: String!
  """
  The log probability of this token.
  """
  logProb: Float!
  """
  A list of integers representing the UTF-8 bytes representation of the token.
  """
  bytes: [Int!]!
}

enum FinishReason {
  STOP
  LENGTH
  TOOL_CALLS
  CONTENT_FILTER
  FUNCTION_CALL
}

enum ServiceTier {
  """
  the system will utilize scale tier credits until they are exhausted.
  """
  AUTO
  """
  the request will be processed using the default service tier with a lower uptime SLA and no latency guarantee.
  """
  DEFAULT
}

input CreateChatCompletionInput {
  """
  A list of messages comprising the conversation so far.
  [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  """
  messages: [ChatCompletionMessageInput!]!
  """
  ID of the model to use. See the
  [model endpoint compatibility](https://platform.openai.com/docs/models/model-endpoint-compatibility)
  table for details on which models work with the Chat API.
  """
  model: String!
  """
  Number between -2.0 and 2.0. Positive values penalize new tokens based on their
  existing frequency in the text so far, decreasing the model's likelihood to
  repeat the same line verbatim.

  [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  """
  frequencyPenalty: Float
  """
  Modify the likelihood of specified tokens appearing in the completion.

  Accepts a JSON object that maps tokens (specified by their token ID in the
  tokenizer) to an associated bias value from -100 to 100. Mathematically, the
  bias is added to the logits generated by the model prior to sampling. The exact
  effect will vary per model, but values between -1 and 1 should decrease or
  increase likelihood of selection; values like -100 or 100 should result in a ban
  or exclusive selection of the relevant token.
  """
  logitBias: Map
  """
  Whether to return log probabilities of the output tokens or not. If true,
  returns the log probabilities of each output token returned in the ` + "`" + `content` + "`" + ` of
  ` + "`" + `message` + "`" + `.
  """
  logProbs: Boolean
  """
  The maximum number of tokens that can be generated in the chat completion.

  The total length of input tokens and generated tokens is limited by the model's
  context length.
  [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken)
  for counting tokens.
  """
  maxTokens: Int
  """
  How many chat completion choices to generate for each input message. Note that
  you will be charged based on the number of generated tokens across all of the
  choices. Keep ` + "`" + `n` + "`" + ` as ` + "`" + `1` + "`" + ` to minimize costs.
  """
  n: Int
  """
  Whether to enable
  [parallel function calling](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling)
  during tool use.
  """
  parallelToolCalls: Boolean
  """
  Number between -2.0 and 2.0. Positive values penalize new tokens based on
  whether they appear in the text so far, increasing the model's likelihood to
  talk about new topics.

  [See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation/parameter-details)
  """
  presencePenalty: Float
  """
  An object specifying the format that the model must output. Compatible with
  [GPT-4 Turbo](https://platform.openai.com/docs/models/gpt-4-and-gpt-4-turbo) and
  all GPT-3.5 Turbo models newer than ` + "`" + `gpt-3.5-turbo-1106` + "`" + `.

  Setting to ` + "`" + `{ "type": "json_object" }` + "`" + ` enables JSON mode, which guarantees the
  message the model generates is valid JSON.

  **Important:** when using JSON mode, you **must** also instruct the model to
  produce JSON yourself via a system or user message. Without this, the model may
  generate an unending stream of whitespace until the generation reaches the token
  limit, resulting in a long-running and seemingly "stuck" request. Also note that
  the message content may be partially cut off if ` + "`" + `finish_reason="length"` + "`" + `, which
  indicates the generation exceeded ` + "`" + `max_tokens` + "`" + ` or the conversation exceeded the
  max context length.
  """
  responseFormat: ResponseFormatInput
  """
  This feature is in Beta. If specified, our system will make a best effort to
  sample deterministically, such that repeated requests with the same ` + "`" + `seed` + "`" + ` and
  parameters should return the same result. Determinism is not guaranteed, and you
  should refer to the ` + "`" + `system_fingerprint` + "`" + ` response parameter to monitor changes
  in the backend.
  """
  seed: Int
  """
  Specifies the latency tier to use for processing the request. This parameter is
  relevant for customers subscribed to the scale tier service:

  - If set to 'auto', the system will utilize scale tier credits until they are
    exhausted.
  - If set to 'default', the request will be processed using the default service
    tier with a lower uptime SLA and no latency guarentee.
  - When not set, the default behavior is 'auto'.

  When this parameter is set, the response body will include the ` + "`" + `service_tier` + "`" + `
  utilized.
  """
  serviceTier: CreateChatCompletionServiceTier
  """
  Up to 4 sequences where the API will stop generating further tokens.
  """
  stop: [String]
  """
  If set, partial message deltas will be sent, like in ChatGPT. Tokens will be
  sent as data-only
  [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)
  as they become available, with the stream terminated by a ` + "`" + `data: [DONE]` + "`" + `
  message.
  [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
  """
  stream: Boolean
  """
  Options for streaming response. Only set this when you set ` + "`" + `stream: true` + "`" + `.
  """
  streamOptions: CreateChatCompletionStreamOptions
  """
  What sampling temperature to use, between 0 and 2. Higher values like 0.8 will
  make the output more random, while lower values like 0.2 will make it more
  focused and deterministic.

  We generally recommend altering this or ` + "`" + `top_p` + "`" + ` but not both.
  """
  temperature: Float
  """
  Controls which (if any) tool is called by the model. ` + "`" + `none` + "`" + ` means the model will
  not call any tool and instead generates a message. ` + "`" + `auto` + "`" + ` means the model can
  pick between generating a message or calling one or more tools. ` + "`" + `required` + "`" + ` means
  the model must call one or more tools. Specifying a particular tool via
  ` + "`" + `{"type": "function", "function": {"name": "my_function"}}` + "`" + ` forces the model to
  call that tool.

  ` + "`" + `none` + "`" + ` is the default when no tools are present. ` + "`" + `auto` + "`" + ` is the default if tools
  are present.
  """
  toolChoice: ChatCompletionToolChoiceOption
  """
  A list of tools the model may call. Currently, only functions are supported as a
  tool. Use this to provide a list of functions the model may generate JSON inputs
  for. A max of 128 functions are supported.
  """
  tools: [ChatCompletionTool]
  """
  An integer between 0 and 20 specifying the number of most likely tokens to
  return at each token position, each with an associated log probability.
  ` + "`" + `logprobs` + "`" + ` must be set to ` + "`" + `true` + "`" + ` if this parameter is used.
  """
  topLogProbs: Int
  """
  An alternative to sampling with temperature, called nucleus sampling, where the
  model considers the results of the tokens with top_p probability mass. So 0.1
  means only the tokens comprising the top 10% probability mass are considered.

  We generally recommend altering this or ` + "`" + `temperature` + "`" + ` but not both.
  """
  topP: Float
  """
  A unique identifier representing your end-user, which can help OpenAI to monitor
  and detect abuse.
  [Learn more](https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids).
  """
  user: String
}

input ChatCompletionMessageInput {
  role: String!
  content: String
  multiContent: [ChatCompletionMessageContentPartInput!]
  name: String
  functionCall: FunctionCallInput
  toolCalls: [ChatCompletionMessageToolCallInput!]
  toolCallId: String
}

input ChatCompletionMessageContentPartInput {
  type: String!
  text: String
  imageUrl: ChatCompletionContentPartImageURLInput
}

input ChatCompletionContentPartImageURLInput {
  url: String!
  detail: ImageDetail
}

input FunctionCallInput {
  """
  The name of the function to call.
  """
  name: String!
  """
  The arguments to call the function with, as generated by the model in JSON format.
  """
  arguments: String!
}

input ChatCompletionMessageToolCallInput {
  """
  The ID of the tool call.
  """
  id: String!
  """
  The function that the model called.
  """
  function: FunctionCallInput!
  """
  The type of the tool. Currently, only ` + "`" + `function` + "`" + ` is supported.
  """
  type: String!
}

input ResponseFormatInput {
  """
  The type of response format being defined: ` + "`" + `text` + "`" + `, ` + "`" + `json_object` + "`" + `, or ` + "`" + `json_schema` + "`" + `
  """
  type: String!
  """
  The schema for the response format, described as a JSON Schema object.
  """
  jsonSchema: JSONSchemaInput
}

input JSONSchemaInput {
  """
  A description of what the response format is for, used by the model to determine how to respond in the format.
  """
  description: String!
  """
  The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  """
  name: String!
  """
  The schema for the response format, described as a JSON Schema object.
  """
  schema: Map!
  """
  Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the ` + "`" + `schema` + "`" + ` field.
  """
  strict: Boolean
}

input CreateChatCompletionStreamOptions {
  """
  If set, an additional chunk will be streamed before the ` + "`" + `data: [DONE]` + "`" + ` message. The ` + "`" + `usage` + "`" + ` field on this chunk shows the token usage statistics for the entire request, and the ` + "`" + `choices` + "`" + ` field will always be an empty array.
  """
  includeUsage: Boolean
}

enum ChatCompletionToolChoiceOption {
  none
  auto
  required
}

input ChatCompletionTool {
  """
  Function definitions for the tool.
  """
  function: ChatCompletionToolFunction
  """
  The type of the tool. Currently, only ` + "`" + `function` + "`" + ` is supported.
  """
  type: String!
}

input ChatCompletionToolFunction {
  """
  The name of the function to be called. Must be a-z, A-Z, 0-9, or contain
  underscores and dashes, with a maximum length of 64.
  """
  name: String!
  """
  A description of what the function does, used by the model to choose when and
  how to call the function.
  """
  description: String!
  """
  Whether to enable strict schema adherence when generating the output. If set to
  true, the model will always follow the exact schema defined in the ` + "`" + `parameters` + "`" + ` field.
  """
  strict: Boolean
  """
  The parameters the functions accepts, described as a JSON Schema object. See the
  [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
  and the
  [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
  documentation about the format.

  Omitting ` + "`" + `parameters` + "`" + ` defines a function with an empty parameter list.
  """
  parameters: Map
}

enum CreateChatCompletionServiceTier {
  auto
  default
}

type ChatCompletionStreamResult {
  """
  A unique identifier for the chat completion. Each chunk has the same ID.
  """
  id: ID!
  """
  The object type, which is always "chat.completion.chunk".
  """
  object: String!
  """
  The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  """
  created: Int!
  """
  The model to generate the completion.
  """
  model: String!
  """
  A list of chat completion choices. Can contain more than one element if n is greater than 1.
  """
  choices: [ChatCompletionStreamChunkChoice!]!
  """
  This fingerprint represents the backend configuration that the model runs with.
  Can be used in conjunction with the ` + "`" + `seed` + "`" + ` request parameter to understand when backend changes have been made that might impact determinism.
  """
  systemFingerprint: String
  """
  Usage statistics for the completion request.
  """
  usage: Usage
}

type ChatCompletionStreamChunkChoice {
  """
  The index of the choice in the list of choices.
  """
  index: Int!
  """
  The partial message delta.
  """
  delta: ChatCompletionStreamResponseDelta!
  """
  The reason the model stopped generating tokens.
  """
  finishReason: FinishReason
}

type ChatCompletionStreamResponseDelta {
  """
  The role of the author of this message.
  """
  role: String!
  """
  The partial content of the message.
  """
  content: String
  """
  The partial tool calls generated by the model.
  """
  toolCalls: [ChatCompletionMessageToolCallChunk!]
  """
  Deprecated. The partial function call information.
  """
  functionCall: FunctionCall
}

type ChatCompletionMessageToolCallChunk {
  """
  The index of the tool call in the list of tool calls.
  """
  index: Int
  """
  The ID of the tool call.
  """
  id: String!
  """
  The type of the tool. Currently, only "function" is supported.
  """
  type: String!
  """
  The partial function call information.
  """
  function: FunctionCallChunk
}

type FunctionCallChunk {
  """
  The name of the function to call.
  """
  name: String!
  """
  The partial arguments to call the function with.
  """
  arguments: String!
}

type Model {
  name: String!
}

type ModelEdge {
  node: Model!
  cursor: String!
}

type ModelConnection {
  edges: [ModelEdge!]!
  pageInfo: PageInfo!
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

type Query {
  models(first: Int, after: String, last: Int, before: String): ModelConnection!
}

type Mutation {
  """
  Creates a model response for the given chat conversation.
  """
  createChatCompletion(input: CreateChatCompletionInput!): ChatCompletionResult!
}

type Subscription {
  """
  Creates a streaming model response for the given chat conversation.
  """
  createChatCompletionStream(input: CreateChatCompletionInput!): ChatCompletionStreamResult!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createChatCompletion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateChatCompletionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateChatCompletionInput2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐCreateChatCompletionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_models_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	return args, nil
}

func (ec *executionContext) field_Subscription_createChatCompletionStream_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateChatCompletionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateChatCompletionInput2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐCreateChatCompletionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ChatCompletionArrayContent_parts(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionArrayContent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionArrayContent_parts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ChatCompletionMessageContentPart)
	fc.Result = res
	return ec.marshalNChatCompletionMessageContentPart2ᚕgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContentPartᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionArrayContent_parts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionArrayContent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChatCompletionMessageContentPart does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionAssistantMessage_role(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionAssistantMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionAssistantMessage_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionAssistantMessage_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionAssistantMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionAssistantMessage_content(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionAssistantMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionAssistantMessage_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ChatCompletionMessageContent)
	fc.Result = res
	return ec.marshalOChatCompletionMessageContent2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionAssistantMessage_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionAssistantMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChatCompletionMessageContent does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionAssistantMessage_name(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionAssistantMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionAssistantMessage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionAssistantMessage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionAssistantMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionAssistantMessage_toolCalls(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionAssistantMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionAssistantMessage_toolCalls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToolCalls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ChatCompletionMessageToolCall)
	fc.Result = res
	return ec.marshalOChatCompletionMessageToolCall2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCallᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionAssistantMessage_toolCalls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionAssistantMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChatCompletionMessageToolCall_id(ctx, field)
			case "function":
				return ec.fieldContext_ChatCompletionMessageToolCall_function(ctx, field)
			case "type":
				return ec.fieldContext_ChatCompletionMessageToolCall_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatCompletionMessageToolCall", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionAssistantMessage_toolCallId(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionAssistantMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionAssistantMessage_toolCallId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToolCallID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionAssistantMessage_toolCallId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionAssistantMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionChoice_index(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionChoice_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionChoice_index(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionChoice_message(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionChoice_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChatCompletionMessage)
	fc.Result = res
	return ec.marshalNChatCompletionMessage2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionChoice_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionChoice_finishReason(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionChoice_finishReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FinishReason)
	fc.Result = res
	return ec.marshalOFinishReason2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFinishReason(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionChoice_finishReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FinishReason does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionChoice_logprobs(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionChoice_logprobs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logprobs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LogProbs)
	fc.Result = res
	return ec.marshalOLogProbs2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐLogProbs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionChoice_logprobs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "content":
				return ec.fieldContext_LogProbs_content(ctx, field)
			case "refusal":
				return ec.fieldContext_LogProbs_refusal(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogProbs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionContentPartImage_imageUrl(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionContentPartImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionContentPartImage_imageUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChatCompletionContentPartImageURL)
	fc.Result = res
	return ec.marshalNChatCompletionContentPartImageURL2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionContentPartImageURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionContentPartImage_imageUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionContentPartImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_ChatCompletionContentPartImageURL_url(ctx, field)
			case "detail":
				return ec.fieldContext_ChatCompletionContentPartImageURL_detail(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatCompletionContentPartImageURL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionContentPartImage_type(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionContentPartImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionContentPartImage_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionContentPartImage_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionContentPartImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionContentPartImageURL_url(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionContentPartImageURL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionContentPartImageURL_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionContentPartImageURL_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionContentPartImageURL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionContentPartImageURL_detail(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionContentPartImageURL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionContentPartImageURL_detail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Detail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ImageDetail)
	fc.Result = res
	return ec.marshalOImageDetail2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐImageDetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionContentPartImageURL_detail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionContentPartImageURL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageDetail does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionContentPartText_text(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionContentPartText) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionContentPartText_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionContentPartText_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionContentPartText",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionContentPartText_type(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionContentPartText) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionContentPartText_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionContentPartText_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionContentPartText",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionMessageToolCall_id(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionMessageToolCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionMessageToolCall_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionMessageToolCall_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionMessageToolCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionMessageToolCall_function(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionMessageToolCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionMessageToolCall_function(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Function, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FunctionCall)
	fc.Result = res
	return ec.marshalNFunctionCall2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFunctionCall(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionMessageToolCall_function(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionMessageToolCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_FunctionCall_name(ctx, field)
			case "arguments":
				return ec.fieldContext_FunctionCall_arguments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionCall", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionMessageToolCall_type(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionMessageToolCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionMessageToolCall_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionMessageToolCall_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionMessageToolCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionMessageToolCallChunk_index(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionMessageToolCallChunk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionMessageToolCallChunk_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionMessageToolCallChunk_index(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionMessageToolCallChunk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionMessageToolCallChunk_id(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionMessageToolCallChunk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionMessageToolCallChunk_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionMessageToolCallChunk_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionMessageToolCallChunk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionMessageToolCallChunk_type(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionMessageToolCallChunk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionMessageToolCallChunk_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionMessageToolCallChunk_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionMessageToolCallChunk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionMessageToolCallChunk_function(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionMessageToolCallChunk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionMessageToolCallChunk_function(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Function, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FunctionCallChunk)
	fc.Result = res
	return ec.marshalOFunctionCallChunk2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFunctionCallChunk(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionMessageToolCallChunk_function(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionMessageToolCallChunk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_FunctionCallChunk_name(ctx, field)
			case "arguments":
				return ec.fieldContext_FunctionCallChunk_arguments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionCallChunk", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionResult_id(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionResult_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionResult_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionResult_object(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionResult_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionResult_object(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionResult_created(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionResult_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionResult_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionResult_model(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionResult_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionResult_model(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionResult_choices(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionResult_choices(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Choices, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChatCompletionChoice)
	fc.Result = res
	return ec.marshalNChatCompletionChoice2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionChoiceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionResult_choices(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "index":
				return ec.fieldContext_ChatCompletionChoice_index(ctx, field)
			case "message":
				return ec.fieldContext_ChatCompletionChoice_message(ctx, field)
			case "finishReason":
				return ec.fieldContext_ChatCompletionChoice_finishReason(ctx, field)
			case "logprobs":
				return ec.fieldContext_ChatCompletionChoice_logprobs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatCompletionChoice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionResult_usage(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionResult_usage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Usage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Usage)
	fc.Result = res
	return ec.marshalNUsage2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionResult_usage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "promptTokens":
				return ec.fieldContext_Usage_promptTokens(ctx, field)
			case "completionTokens":
				return ec.fieldContext_Usage_completionTokens(ctx, field)
			case "totalTokens":
				return ec.fieldContext_Usage_totalTokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Usage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionResult_systemFingerprint(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionResult_systemFingerprint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemFingerprint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionResult_systemFingerprint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamChunkChoice_index(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamChunkChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamChunkChoice_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamChunkChoice_index(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamChunkChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamChunkChoice_delta(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamChunkChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamChunkChoice_delta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Delta, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChatCompletionStreamResponseDelta)
	fc.Result = res
	return ec.marshalNChatCompletionStreamResponseDelta2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionStreamResponseDelta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamChunkChoice_delta(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamChunkChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "role":
				return ec.fieldContext_ChatCompletionStreamResponseDelta_role(ctx, field)
			case "content":
				return ec.fieldContext_ChatCompletionStreamResponseDelta_content(ctx, field)
			case "toolCalls":
				return ec.fieldContext_ChatCompletionStreamResponseDelta_toolCalls(ctx, field)
			case "functionCall":
				return ec.fieldContext_ChatCompletionStreamResponseDelta_functionCall(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatCompletionStreamResponseDelta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamChunkChoice_finishReason(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamChunkChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamChunkChoice_finishReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FinishReason)
	fc.Result = res
	return ec.marshalOFinishReason2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFinishReason(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamChunkChoice_finishReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamChunkChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FinishReason does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResponseDelta_role(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResponseDelta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResponseDelta_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResponseDelta_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResponseDelta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResponseDelta_content(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResponseDelta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResponseDelta_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResponseDelta_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResponseDelta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResponseDelta_toolCalls(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResponseDelta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResponseDelta_toolCalls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToolCalls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ChatCompletionMessageToolCallChunk)
	fc.Result = res
	return ec.marshalOChatCompletionMessageToolCallChunk2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCallChunkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResponseDelta_toolCalls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResponseDelta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "index":
				return ec.fieldContext_ChatCompletionMessageToolCallChunk_index(ctx, field)
			case "id":
				return ec.fieldContext_ChatCompletionMessageToolCallChunk_id(ctx, field)
			case "type":
				return ec.fieldContext_ChatCompletionMessageToolCallChunk_type(ctx, field)
			case "function":
				return ec.fieldContext_ChatCompletionMessageToolCallChunk_function(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatCompletionMessageToolCallChunk", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResponseDelta_functionCall(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResponseDelta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResponseDelta_functionCall(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FunctionCall, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FunctionCall)
	fc.Result = res
	return ec.marshalOFunctionCall2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFunctionCall(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResponseDelta_functionCall(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResponseDelta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_FunctionCall_name(ctx, field)
			case "arguments":
				return ec.fieldContext_FunctionCall_arguments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FunctionCall", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResult_id(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResult_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResult_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResult_object(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResult_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResult_object(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResult_created(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResult_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResult_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResult_model(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResult_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResult_model(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResult_choices(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResult_choices(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Choices, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChatCompletionStreamChunkChoice)
	fc.Result = res
	return ec.marshalNChatCompletionStreamChunkChoice2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionStreamChunkChoiceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResult_choices(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "index":
				return ec.fieldContext_ChatCompletionStreamChunkChoice_index(ctx, field)
			case "delta":
				return ec.fieldContext_ChatCompletionStreamChunkChoice_delta(ctx, field)
			case "finishReason":
				return ec.fieldContext_ChatCompletionStreamChunkChoice_finishReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatCompletionStreamChunkChoice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResult_systemFingerprint(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResult_systemFingerprint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemFingerprint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResult_systemFingerprint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionStreamResult_usage(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionStreamResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionStreamResult_usage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Usage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Usage)
	fc.Result = res
	return ec.marshalOUsage2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionStreamResult_usage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionStreamResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "promptTokens":
				return ec.fieldContext_Usage_promptTokens(ctx, field)
			case "completionTokens":
				return ec.fieldContext_Usage_completionTokens(ctx, field)
			case "totalTokens":
				return ec.fieldContext_Usage_totalTokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Usage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionSystemMessage_role(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionSystemMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionSystemMessage_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionSystemMessage_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionSystemMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionSystemMessage_content(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionSystemMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionSystemMessage_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChatCompletionMessageContent)
	fc.Result = res
	return ec.marshalNChatCompletionMessageContent2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionSystemMessage_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionSystemMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChatCompletionMessageContent does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionSystemMessage_name(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionSystemMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionSystemMessage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionSystemMessage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionSystemMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionTextContent_text(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionTextContent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionTextContent_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionTextContent_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionTextContent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionToolMessage_role(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionToolMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionToolMessage_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionToolMessage_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionToolMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionToolMessage_content(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionToolMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionToolMessage_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChatCompletionMessageContent)
	fc.Result = res
	return ec.marshalNChatCompletionMessageContent2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionToolMessage_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionToolMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChatCompletionMessageContent does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionToolMessage_name(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionToolMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionToolMessage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionToolMessage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionToolMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionToolMessage_toolCallId(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionToolMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionToolMessage_toolCallId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToolCallID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionToolMessage_toolCallId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionToolMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionUserMessage_role(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionUserMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionUserMessage_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionUserMessage_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionUserMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionUserMessage_content(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionUserMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionUserMessage_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ChatCompletionMessageContent)
	fc.Result = res
	return ec.marshalNChatCompletionMessageContent2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionUserMessage_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionUserMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ChatCompletionMessageContent does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChatCompletionUserMessage_name(ctx context.Context, field graphql.CollectedField, obj *model.ChatCompletionUserMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChatCompletionUserMessage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChatCompletionUserMessage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChatCompletionUserMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionCall_name(ctx context.Context, field graphql.CollectedField, obj *model.FunctionCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionCall_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionCall_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionCall_arguments(ctx context.Context, field graphql.CollectedField, obj *model.FunctionCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionCall_arguments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Arguments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionCall_arguments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionCallChunk_name(ctx context.Context, field graphql.CollectedField, obj *model.FunctionCallChunk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionCallChunk_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionCallChunk_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionCallChunk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FunctionCallChunk_arguments(ctx context.Context, field graphql.CollectedField, obj *model.FunctionCallChunk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FunctionCallChunk_arguments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Arguments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FunctionCallChunk_arguments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FunctionCallChunk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogProbs_content(ctx context.Context, field graphql.CollectedField, obj *model.LogProbs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogProbs_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TokenLogProb)
	fc.Result = res
	return ec.marshalNTokenLogProb2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐTokenLogProbᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogProbs_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogProbs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_TokenLogProb_token(ctx, field)
			case "logProb":
				return ec.fieldContext_TokenLogProb_logProb(ctx, field)
			case "bytes":
				return ec.fieldContext_TokenLogProb_bytes(ctx, field)
			case "topLogProbs":
				return ec.fieldContext_TokenLogProb_topLogProbs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TokenLogProb", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogProbs_refusal(ctx context.Context, field graphql.CollectedField, obj *model.LogProbs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogProbs_refusal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Refusal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TokenLogProb)
	fc.Result = res
	return ec.marshalNTokenLogProb2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐTokenLogProbᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogProbs_refusal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogProbs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_TokenLogProb_token(ctx, field)
			case "logProb":
				return ec.fieldContext_TokenLogProb_logProb(ctx, field)
			case "bytes":
				return ec.fieldContext_TokenLogProb_bytes(ctx, field)
			case "topLogProbs":
				return ec.fieldContext_TokenLogProb_topLogProbs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TokenLogProb", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_name(ctx context.Context, field graphql.CollectedField, obj *model.Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.ModelConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ModelEdge)
	fc.Result = res
	return ec.marshalNModelEdge2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐModelEdgeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ModelEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ModelEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.ModelConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.ModelEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Model)
	fc.Result = res
	return ec.marshalNModel2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐModel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Model_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Model", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.ModelEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createChatCompletion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createChatCompletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateChatCompletion(rctx, fc.Args["input"].(model.CreateChatCompletionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChatCompletionResult)
	fc.Result = res
	return ec.marshalNChatCompletionResult2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createChatCompletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChatCompletionResult_id(ctx, field)
			case "object":
				return ec.fieldContext_ChatCompletionResult_object(ctx, field)
			case "created":
				return ec.fieldContext_ChatCompletionResult_created(ctx, field)
			case "model":
				return ec.fieldContext_ChatCompletionResult_model(ctx, field)
			case "choices":
				return ec.fieldContext_ChatCompletionResult_choices(ctx, field)
			case "usage":
				return ec.fieldContext_ChatCompletionResult_usage(ctx, field)
			case "systemFingerprint":
				return ec.fieldContext_ChatCompletionResult_systemFingerprint(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatCompletionResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createChatCompletion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_models(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_models(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Models(rctx, fc.Args["first"].(*int), fc.Args["after"].(*string), fc.Args["last"].(*int), fc.Args["before"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ModelConnection)
	fc.Result = res
	return ec.marshalNModelConnection2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐModelConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_models(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ModelConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ModelConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_models_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_createChatCompletionStream(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_createChatCompletionStream(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().CreateChatCompletionStream(rctx, fc.Args["input"].(model.CreateChatCompletionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ChatCompletionStreamResult):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNChatCompletionStreamResult2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionStreamResult(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_createChatCompletionStream(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ChatCompletionStreamResult_id(ctx, field)
			case "object":
				return ec.fieldContext_ChatCompletionStreamResult_object(ctx, field)
			case "created":
				return ec.fieldContext_ChatCompletionStreamResult_created(ctx, field)
			case "model":
				return ec.fieldContext_ChatCompletionStreamResult_model(ctx, field)
			case "choices":
				return ec.fieldContext_ChatCompletionStreamResult_choices(ctx, field)
			case "systemFingerprint":
				return ec.fieldContext_ChatCompletionStreamResult_systemFingerprint(ctx, field)
			case "usage":
				return ec.fieldContext_ChatCompletionStreamResult_usage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChatCompletionStreamResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_createChatCompletionStream_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TokenLogProb_token(ctx context.Context, field graphql.CollectedField, obj *model.TokenLogProb) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenLogProb_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenLogProb_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenLogProb",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenLogProb_logProb(ctx context.Context, field graphql.CollectedField, obj *model.TokenLogProb) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenLogProb_logProb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogProb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenLogProb_logProb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenLogProb",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenLogProb_bytes(ctx context.Context, field graphql.CollectedField, obj *model.TokenLogProb) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenLogProb_bytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenLogProb_bytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenLogProb",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenLogProb_topLogProbs(ctx context.Context, field graphql.CollectedField, obj *model.TokenLogProb) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenLogProb_topLogProbs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopLogProbs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TopLogProb)
	fc.Result = res
	return ec.marshalNTopLogProb2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐTopLogProbᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenLogProb_topLogProbs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenLogProb",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_TopLogProb_token(ctx, field)
			case "logProb":
				return ec.fieldContext_TopLogProb_logProb(ctx, field)
			case "bytes":
				return ec.fieldContext_TopLogProb_bytes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TopLogProb", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopLogProb_token(ctx context.Context, field graphql.CollectedField, obj *model.TopLogProb) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopLogProb_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopLogProb_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopLogProb",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopLogProb_logProb(ctx context.Context, field graphql.CollectedField, obj *model.TopLogProb) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopLogProb_logProb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogProb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopLogProb_logProb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopLogProb",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TopLogProb_bytes(ctx context.Context, field graphql.CollectedField, obj *model.TopLogProb) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TopLogProb_bytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TopLogProb_bytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TopLogProb",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Usage_promptTokens(ctx context.Context, field graphql.CollectedField, obj *model.Usage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Usage_promptTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PromptTokens, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Usage_promptTokens(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Usage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Usage_completionTokens(ctx context.Context, field graphql.CollectedField, obj *model.Usage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Usage_completionTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletionTokens, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Usage_completionTokens(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Usage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Usage_totalTokens(ctx context.Context, field graphql.CollectedField, obj *model.Usage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Usage_totalTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTokens, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Usage_totalTokens(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Usage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputChatCompletionContentPartImageURLInput(ctx context.Context, obj interface{}) (model.ChatCompletionContentPartImageURLInput, error) {
	var it model.ChatCompletionContentPartImageURLInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "detail"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "detail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("detail"))
			data, err := ec.unmarshalOImageDetail2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐImageDetail(ctx, v)
			if err != nil {
				return it, err
			}
			it.Detail = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChatCompletionMessageContentPartInput(ctx context.Context, obj interface{}) (model.ChatCompletionMessageContentPartInput, error) {
	var it model.ChatCompletionMessageContentPartInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "text", "imageUrl"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "imageUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageUrl"))
			data, err := ec.unmarshalOChatCompletionContentPartImageURLInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionContentPartImageURLInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageURL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChatCompletionMessageInput(ctx context.Context, obj interface{}) (model.ChatCompletionMessageInput, error) {
	var it model.ChatCompletionMessageInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"role", "content", "multiContent", "name", "functionCall", "toolCalls", "toolCallId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "content":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("content"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Content = data
		case "multiContent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("multiContent"))
			data, err := ec.unmarshalOChatCompletionMessageContentPartInput2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContentPartInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.MultiContent = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "functionCall":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("functionCall"))
			data, err := ec.unmarshalOFunctionCallInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFunctionCallInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FunctionCall = data
		case "toolCalls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCalls"))
			data, err := ec.unmarshalOChatCompletionMessageToolCallInput2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCallInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCalls = data
		case "toolCallId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCallId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCallID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChatCompletionMessageToolCallInput(ctx context.Context, obj interface{}) (model.ChatCompletionMessageToolCallInput, error) {
	var it model.ChatCompletionMessageToolCallInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "function", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "function":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("function"))
			data, err := ec.unmarshalNFunctionCallInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFunctionCallInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Function = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChatCompletionTool(ctx context.Context, obj interface{}) (model.ChatCompletionTool, error) {
	var it model.ChatCompletionTool
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"function", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "function":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("function"))
			data, err := ec.unmarshalOChatCompletionToolFunction2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionToolFunction(ctx, v)
			if err != nil {
				return it, err
			}
			it.Function = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChatCompletionToolFunction(ctx context.Context, obj interface{}) (model.ChatCompletionToolFunction, error) {
	var it model.ChatCompletionToolFunction
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "strict", "parameters"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "strict":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("strict"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Strict = data
		case "parameters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateChatCompletionInput(ctx context.Context, obj interface{}) (model.CreateChatCompletionInput, error) {
	var it model.CreateChatCompletionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"messages", "model", "frequencyPenalty", "logitBias", "logProbs", "maxTokens", "n", "parallelToolCalls", "presencePenalty", "responseFormat", "seed", "serviceTier", "stop", "stream", "streamOptions", "temperature", "toolChoice", "tools", "topLogProbs", "topP", "user"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "messages":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messages"))
			data, err := ec.unmarshalNChatCompletionMessageInput2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Messages = data
		case "model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = data
		case "frequencyPenalty":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frequencyPenalty"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FrequencyPenalty = data
		case "logitBias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logitBias"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogitBias = data
		case "logProbs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logProbs"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogProbs = data
		case "maxTokens":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTokens"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTokens = data
		case "n":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("n"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.N = data
		case "parallelToolCalls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parallelToolCalls"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParallelToolCalls = data
		case "presencePenalty":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("presencePenalty"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PresencePenalty = data
		case "responseFormat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("responseFormat"))
			data, err := ec.unmarshalOResponseFormatInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐResponseFormatInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResponseFormat = data
		case "seed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seed"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Seed = data
		case "serviceTier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceTier"))
			data, err := ec.unmarshalOCreateChatCompletionServiceTier2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐCreateChatCompletionServiceTier(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceTier = data
		case "stop":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stop = data
		case "stream":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stream"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stream = data
		case "streamOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamOptions"))
			data, err := ec.unmarshalOCreateChatCompletionStreamOptions2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐCreateChatCompletionStreamOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamOptions = data
		case "temperature":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("temperature"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Temperature = data
		case "toolChoice":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolChoice"))
			data, err := ec.unmarshalOChatCompletionToolChoiceOption2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionToolChoiceOption(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolChoice = data
		case "tools":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tools"))
			data, err := ec.unmarshalOChatCompletionTool2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionTool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tools = data
		case "topLogProbs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topLogProbs"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopLogProbs = data
		case "topP":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topP"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopP = data
		case "user":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.User = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateChatCompletionStreamOptions(ctx context.Context, obj interface{}) (model.CreateChatCompletionStreamOptions, error) {
	var it model.CreateChatCompletionStreamOptions
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"includeUsage"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "includeUsage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeUsage"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeUsage = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFunctionCallInput(ctx context.Context, obj interface{}) (model.FunctionCallInput, error) {
	var it model.FunctionCallInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "arguments"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "arguments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arguments"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Arguments = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJSONSchemaInput(ctx context.Context, obj interface{}) (model.JSONSchemaInput, error) {
	var it model.JSONSchemaInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "name", "schema", "strict"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "schema":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schema"))
			data, err := ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Schema = data
		case "strict":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("strict"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Strict = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResponseFormatInput(ctx context.Context, obj interface{}) (model.ResponseFormatInput, error) {
	var it model.ResponseFormatInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "jsonSchema"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "jsonSchema":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jsonSchema"))
			data, err := ec.unmarshalOJSONSchemaInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐJSONSchemaInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.JSONSchema = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _ChatCompletionMessage(ctx context.Context, sel ast.SelectionSet, obj model.ChatCompletionMessage) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ChatCompletionSystemMessage:
		return ec._ChatCompletionSystemMessage(ctx, sel, &obj)
	case *model.ChatCompletionSystemMessage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChatCompletionSystemMessage(ctx, sel, obj)
	case model.ChatCompletionUserMessage:
		return ec._ChatCompletionUserMessage(ctx, sel, &obj)
	case *model.ChatCompletionUserMessage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChatCompletionUserMessage(ctx, sel, obj)
	case model.ChatCompletionAssistantMessage:
		return ec._ChatCompletionAssistantMessage(ctx, sel, &obj)
	case *model.ChatCompletionAssistantMessage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChatCompletionAssistantMessage(ctx, sel, obj)
	case model.ChatCompletionToolMessage:
		return ec._ChatCompletionToolMessage(ctx, sel, &obj)
	case *model.ChatCompletionToolMessage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChatCompletionToolMessage(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ChatCompletionMessageContent(ctx context.Context, sel ast.SelectionSet, obj model.ChatCompletionMessageContent) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ChatCompletionTextContent:
		return ec._ChatCompletionTextContent(ctx, sel, &obj)
	case *model.ChatCompletionTextContent:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChatCompletionTextContent(ctx, sel, obj)
	case model.ChatCompletionArrayContent:
		return ec._ChatCompletionArrayContent(ctx, sel, &obj)
	case *model.ChatCompletionArrayContent:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChatCompletionArrayContent(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ChatCompletionMessageContentPart(ctx context.Context, sel ast.SelectionSet, obj model.ChatCompletionMessageContentPart) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ChatCompletionContentPartText:
		return ec._ChatCompletionContentPartText(ctx, sel, &obj)
	case *model.ChatCompletionContentPartText:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChatCompletionContentPartText(ctx, sel, obj)
	case model.ChatCompletionContentPartImage:
		return ec._ChatCompletionContentPartImage(ctx, sel, &obj)
	case *model.ChatCompletionContentPartImage:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChatCompletionContentPartImage(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var chatCompletionArrayContentImplementors = []string{"ChatCompletionArrayContent", "ChatCompletionMessageContent"}

func (ec *executionContext) _ChatCompletionArrayContent(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionArrayContent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionArrayContentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionArrayContent")
		case "parts":
			out.Values[i] = ec._ChatCompletionArrayContent_parts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionAssistantMessageImplementors = []string{"ChatCompletionAssistantMessage", "ChatCompletionMessage"}

func (ec *executionContext) _ChatCompletionAssistantMessage(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionAssistantMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionAssistantMessageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionAssistantMessage")
		case "role":
			out.Values[i] = ec._ChatCompletionAssistantMessage_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "content":
			out.Values[i] = ec._ChatCompletionAssistantMessage_content(ctx, field, obj)
		case "name":
			out.Values[i] = ec._ChatCompletionAssistantMessage_name(ctx, field, obj)
		case "toolCalls":
			out.Values[i] = ec._ChatCompletionAssistantMessage_toolCalls(ctx, field, obj)
		case "toolCallId":
			out.Values[i] = ec._ChatCompletionAssistantMessage_toolCallId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionChoiceImplementors = []string{"ChatCompletionChoice"}

func (ec *executionContext) _ChatCompletionChoice(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionChoice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionChoiceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionChoice")
		case "index":
			out.Values[i] = ec._ChatCompletionChoice_index(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ChatCompletionChoice_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "finishReason":
			out.Values[i] = ec._ChatCompletionChoice_finishReason(ctx, field, obj)
		case "logprobs":
			out.Values[i] = ec._ChatCompletionChoice_logprobs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionContentPartImageImplementors = []string{"ChatCompletionContentPartImage", "ChatCompletionMessageContentPart"}

func (ec *executionContext) _ChatCompletionContentPartImage(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionContentPartImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionContentPartImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionContentPartImage")
		case "imageUrl":
			out.Values[i] = ec._ChatCompletionContentPartImage_imageUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ChatCompletionContentPartImage_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionContentPartImageURLImplementors = []string{"ChatCompletionContentPartImageURL"}

func (ec *executionContext) _ChatCompletionContentPartImageURL(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionContentPartImageURL) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionContentPartImageURLImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionContentPartImageURL")
		case "url":
			out.Values[i] = ec._ChatCompletionContentPartImageURL_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detail":
			out.Values[i] = ec._ChatCompletionContentPartImageURL_detail(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionContentPartTextImplementors = []string{"ChatCompletionContentPartText", "ChatCompletionMessageContentPart"}

func (ec *executionContext) _ChatCompletionContentPartText(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionContentPartText) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionContentPartTextImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionContentPartText")
		case "text":
			out.Values[i] = ec._ChatCompletionContentPartText_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ChatCompletionContentPartText_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionMessageToolCallImplementors = []string{"ChatCompletionMessageToolCall"}

func (ec *executionContext) _ChatCompletionMessageToolCall(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionMessageToolCall) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionMessageToolCallImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionMessageToolCall")
		case "id":
			out.Values[i] = ec._ChatCompletionMessageToolCall_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "function":
			out.Values[i] = ec._ChatCompletionMessageToolCall_function(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ChatCompletionMessageToolCall_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionMessageToolCallChunkImplementors = []string{"ChatCompletionMessageToolCallChunk"}

func (ec *executionContext) _ChatCompletionMessageToolCallChunk(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionMessageToolCallChunk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionMessageToolCallChunkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionMessageToolCallChunk")
		case "index":
			out.Values[i] = ec._ChatCompletionMessageToolCallChunk_index(ctx, field, obj)
		case "id":
			out.Values[i] = ec._ChatCompletionMessageToolCallChunk_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ChatCompletionMessageToolCallChunk_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "function":
			out.Values[i] = ec._ChatCompletionMessageToolCallChunk_function(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionResultImplementors = []string{"ChatCompletionResult"}

func (ec *executionContext) _ChatCompletionResult(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionResult")
		case "id":
			out.Values[i] = ec._ChatCompletionResult_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "object":
			out.Values[i] = ec._ChatCompletionResult_object(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "created":
			out.Values[i] = ec._ChatCompletionResult_created(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "model":
			out.Values[i] = ec._ChatCompletionResult_model(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "choices":
			out.Values[i] = ec._ChatCompletionResult_choices(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "usage":
			out.Values[i] = ec._ChatCompletionResult_usage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "systemFingerprint":
			out.Values[i] = ec._ChatCompletionResult_systemFingerprint(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionStreamChunkChoiceImplementors = []string{"ChatCompletionStreamChunkChoice"}

func (ec *executionContext) _ChatCompletionStreamChunkChoice(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionStreamChunkChoice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionStreamChunkChoiceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionStreamChunkChoice")
		case "index":
			out.Values[i] = ec._ChatCompletionStreamChunkChoice_index(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "delta":
			out.Values[i] = ec._ChatCompletionStreamChunkChoice_delta(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "finishReason":
			out.Values[i] = ec._ChatCompletionStreamChunkChoice_finishReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionStreamResponseDeltaImplementors = []string{"ChatCompletionStreamResponseDelta"}

func (ec *executionContext) _ChatCompletionStreamResponseDelta(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionStreamResponseDelta) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionStreamResponseDeltaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionStreamResponseDelta")
		case "role":
			out.Values[i] = ec._ChatCompletionStreamResponseDelta_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "content":
			out.Values[i] = ec._ChatCompletionStreamResponseDelta_content(ctx, field, obj)
		case "toolCalls":
			out.Values[i] = ec._ChatCompletionStreamResponseDelta_toolCalls(ctx, field, obj)
		case "functionCall":
			out.Values[i] = ec._ChatCompletionStreamResponseDelta_functionCall(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionStreamResultImplementors = []string{"ChatCompletionStreamResult"}

func (ec *executionContext) _ChatCompletionStreamResult(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionStreamResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionStreamResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionStreamResult")
		case "id":
			out.Values[i] = ec._ChatCompletionStreamResult_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "object":
			out.Values[i] = ec._ChatCompletionStreamResult_object(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "created":
			out.Values[i] = ec._ChatCompletionStreamResult_created(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "model":
			out.Values[i] = ec._ChatCompletionStreamResult_model(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "choices":
			out.Values[i] = ec._ChatCompletionStreamResult_choices(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "systemFingerprint":
			out.Values[i] = ec._ChatCompletionStreamResult_systemFingerprint(ctx, field, obj)
		case "usage":
			out.Values[i] = ec._ChatCompletionStreamResult_usage(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionSystemMessageImplementors = []string{"ChatCompletionSystemMessage", "ChatCompletionMessage"}

func (ec *executionContext) _ChatCompletionSystemMessage(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionSystemMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionSystemMessageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionSystemMessage")
		case "role":
			out.Values[i] = ec._ChatCompletionSystemMessage_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "content":
			out.Values[i] = ec._ChatCompletionSystemMessage_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ChatCompletionSystemMessage_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionTextContentImplementors = []string{"ChatCompletionTextContent", "ChatCompletionMessageContent"}

func (ec *executionContext) _ChatCompletionTextContent(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionTextContent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionTextContentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionTextContent")
		case "text":
			out.Values[i] = ec._ChatCompletionTextContent_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionToolMessageImplementors = []string{"ChatCompletionToolMessage", "ChatCompletionMessage"}

func (ec *executionContext) _ChatCompletionToolMessage(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionToolMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionToolMessageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionToolMessage")
		case "role":
			out.Values[i] = ec._ChatCompletionToolMessage_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "content":
			out.Values[i] = ec._ChatCompletionToolMessage_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ChatCompletionToolMessage_name(ctx, field, obj)
		case "toolCallId":
			out.Values[i] = ec._ChatCompletionToolMessage_toolCallId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chatCompletionUserMessageImplementors = []string{"ChatCompletionUserMessage", "ChatCompletionMessage"}

func (ec *executionContext) _ChatCompletionUserMessage(ctx context.Context, sel ast.SelectionSet, obj *model.ChatCompletionUserMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chatCompletionUserMessageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChatCompletionUserMessage")
		case "role":
			out.Values[i] = ec._ChatCompletionUserMessage_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "content":
			out.Values[i] = ec._ChatCompletionUserMessage_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ChatCompletionUserMessage_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var functionCallImplementors = []string{"FunctionCall"}

func (ec *executionContext) _FunctionCall(ctx context.Context, sel ast.SelectionSet, obj *model.FunctionCall) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, functionCallImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionCall")
		case "name":
			out.Values[i] = ec._FunctionCall_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "arguments":
			out.Values[i] = ec._FunctionCall_arguments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var functionCallChunkImplementors = []string{"FunctionCallChunk"}

func (ec *executionContext) _FunctionCallChunk(ctx context.Context, sel ast.SelectionSet, obj *model.FunctionCallChunk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, functionCallChunkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FunctionCallChunk")
		case "name":
			out.Values[i] = ec._FunctionCallChunk_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "arguments":
			out.Values[i] = ec._FunctionCallChunk_arguments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logProbsImplementors = []string{"LogProbs"}

func (ec *executionContext) _LogProbs(ctx context.Context, sel ast.SelectionSet, obj *model.LogProbs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logProbsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogProbs")
		case "content":
			out.Values[i] = ec._LogProbs_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refusal":
			out.Values[i] = ec._LogProbs_refusal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelImplementors = []string{"Model"}

func (ec *executionContext) _Model(ctx context.Context, sel ast.SelectionSet, obj *model.Model) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Model")
		case "name":
			out.Values[i] = ec._Model_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelConnectionImplementors = []string{"ModelConnection"}

func (ec *executionContext) _ModelConnection(ctx context.Context, sel ast.SelectionSet, obj *model.ModelConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelConnection")
		case "edges":
			out.Values[i] = ec._ModelConnection_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._ModelConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelEdgeImplementors = []string{"ModelEdge"}

func (ec *executionContext) _ModelEdge(ctx context.Context, sel ast.SelectionSet, obj *model.ModelEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelEdge")
		case "node":
			out.Values[i] = ec._ModelEdge_node(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._ModelEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createChatCompletion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createChatCompletion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "models":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_models(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "createChatCompletionStream":
		return ec._Subscription_createChatCompletionStream(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var tokenLogProbImplementors = []string{"TokenLogProb"}

func (ec *executionContext) _TokenLogProb(ctx context.Context, sel ast.SelectionSet, obj *model.TokenLogProb) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tokenLogProbImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TokenLogProb")
		case "token":
			out.Values[i] = ec._TokenLogProb_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "logProb":
			out.Values[i] = ec._TokenLogProb_logProb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bytes":
			out.Values[i] = ec._TokenLogProb_bytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "topLogProbs":
			out.Values[i] = ec._TokenLogProb_topLogProbs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var topLogProbImplementors = []string{"TopLogProb"}

func (ec *executionContext) _TopLogProb(ctx context.Context, sel ast.SelectionSet, obj *model.TopLogProb) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, topLogProbImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TopLogProb")
		case "token":
			out.Values[i] = ec._TopLogProb_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "logProb":
			out.Values[i] = ec._TopLogProb_logProb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bytes":
			out.Values[i] = ec._TopLogProb_bytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var usageImplementors = []string{"Usage"}

func (ec *executionContext) _Usage(ctx context.Context, sel ast.SelectionSet, obj *model.Usage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, usageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Usage")
		case "promptTokens":
			out.Values[i] = ec._Usage_promptTokens(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "completionTokens":
			out.Values[i] = ec._Usage_completionTokens(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalTokens":
			out.Values[i] = ec._Usage_totalTokens(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNChatCompletionChoice2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionChoiceᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ChatCompletionChoice) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChatCompletionChoice2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionChoice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChatCompletionChoice2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionChoice(ctx context.Context, sel ast.SelectionSet, v *model.ChatCompletionChoice) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionChoice(ctx, sel, v)
}

func (ec *executionContext) marshalNChatCompletionContentPartImageURL2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionContentPartImageURL(ctx context.Context, sel ast.SelectionSet, v *model.ChatCompletionContentPartImageURL) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionContentPartImageURL(ctx, sel, v)
}

func (ec *executionContext) marshalNChatCompletionMessage2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessage(ctx context.Context, sel ast.SelectionSet, v model.ChatCompletionMessage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionMessage(ctx, sel, v)
}

func (ec *executionContext) marshalNChatCompletionMessageContent2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContent(ctx context.Context, sel ast.SelectionSet, v model.ChatCompletionMessageContent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionMessageContent(ctx, sel, v)
}

func (ec *executionContext) marshalNChatCompletionMessageContentPart2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContentPart(ctx context.Context, sel ast.SelectionSet, v model.ChatCompletionMessageContentPart) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionMessageContentPart(ctx, sel, v)
}

func (ec *executionContext) marshalNChatCompletionMessageContentPart2ᚕgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContentPartᚄ(ctx context.Context, sel ast.SelectionSet, v []model.ChatCompletionMessageContentPart) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChatCompletionMessageContentPart2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContentPart(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNChatCompletionMessageContentPartInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContentPartInput(ctx context.Context, v interface{}) (*model.ChatCompletionMessageContentPartInput, error) {
	res, err := ec.unmarshalInputChatCompletionMessageContentPartInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNChatCompletionMessageInput2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageInputᚄ(ctx context.Context, v interface{}) ([]*model.ChatCompletionMessageInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.ChatCompletionMessageInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChatCompletionMessageInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNChatCompletionMessageInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageInput(ctx context.Context, v interface{}) (*model.ChatCompletionMessageInput, error) {
	res, err := ec.unmarshalInputChatCompletionMessageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChatCompletionMessageToolCall2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCall(ctx context.Context, sel ast.SelectionSet, v *model.ChatCompletionMessageToolCall) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionMessageToolCall(ctx, sel, v)
}

func (ec *executionContext) marshalNChatCompletionMessageToolCallChunk2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCallChunk(ctx context.Context, sel ast.SelectionSet, v *model.ChatCompletionMessageToolCallChunk) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionMessageToolCallChunk(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChatCompletionMessageToolCallInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCallInput(ctx context.Context, v interface{}) (*model.ChatCompletionMessageToolCallInput, error) {
	res, err := ec.unmarshalInputChatCompletionMessageToolCallInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChatCompletionResult2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionResult(ctx context.Context, sel ast.SelectionSet, v model.ChatCompletionResult) graphql.Marshaler {
	return ec._ChatCompletionResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNChatCompletionResult2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionResult(ctx context.Context, sel ast.SelectionSet, v *model.ChatCompletionResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionResult(ctx, sel, v)
}

func (ec *executionContext) marshalNChatCompletionStreamChunkChoice2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionStreamChunkChoiceᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ChatCompletionStreamChunkChoice) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChatCompletionStreamChunkChoice2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionStreamChunkChoice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChatCompletionStreamChunkChoice2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionStreamChunkChoice(ctx context.Context, sel ast.SelectionSet, v *model.ChatCompletionStreamChunkChoice) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionStreamChunkChoice(ctx, sel, v)
}

func (ec *executionContext) marshalNChatCompletionStreamResponseDelta2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionStreamResponseDelta(ctx context.Context, sel ast.SelectionSet, v *model.ChatCompletionStreamResponseDelta) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionStreamResponseDelta(ctx, sel, v)
}

func (ec *executionContext) marshalNChatCompletionStreamResult2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionStreamResult(ctx context.Context, sel ast.SelectionSet, v model.ChatCompletionStreamResult) graphql.Marshaler {
	return ec._ChatCompletionStreamResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNChatCompletionStreamResult2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionStreamResult(ctx context.Context, sel ast.SelectionSet, v *model.ChatCompletionStreamResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChatCompletionStreamResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateChatCompletionInput2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐCreateChatCompletionInput(ctx context.Context, v interface{}) (model.CreateChatCompletionInput, error) {
	res, err := ec.unmarshalInputCreateChatCompletionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNFunctionCall2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFunctionCall(ctx context.Context, sel ast.SelectionSet, v *model.FunctionCall) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FunctionCall(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFunctionCallInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFunctionCallInput(ctx context.Context, v interface{}) (*model.FunctionCallInput, error) {
	res, err := ec.unmarshalInputFunctionCallInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNModel2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐModel(ctx context.Context, sel ast.SelectionSet, v *model.Model) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Model(ctx, sel, v)
}

func (ec *executionContext) marshalNModelConnection2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐModelConnection(ctx context.Context, sel ast.SelectionSet, v model.ModelConnection) graphql.Marshaler {
	return ec._ModelConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNModelConnection2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐModelConnection(ctx context.Context, sel ast.SelectionSet, v *model.ModelConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ModelConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNModelEdge2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐModelEdgeᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ModelEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNModelEdge2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐModelEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNModelEdge2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐModelEdge(ctx context.Context, sel ast.SelectionSet, v *model.ModelEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ModelEdge(ctx, sel, v)
}

func (ec *executionContext) marshalNPageInfo2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTokenLogProb2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐTokenLogProbᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TokenLogProb) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTokenLogProb2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐTokenLogProb(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTokenLogProb2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐTokenLogProb(ctx context.Context, sel ast.SelectionSet, v *model.TokenLogProb) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TokenLogProb(ctx, sel, v)
}

func (ec *executionContext) marshalNTopLogProb2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐTopLogProbᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TopLogProb) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTopLogProb2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐTopLogProb(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTopLogProb2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐTopLogProb(ctx context.Context, sel ast.SelectionSet, v *model.TopLogProb) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TopLogProb(ctx, sel, v)
}

func (ec *executionContext) marshalNUsage2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐUsage(ctx context.Context, sel ast.SelectionSet, v *model.Usage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Usage(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOChatCompletionContentPartImageURLInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionContentPartImageURLInput(ctx context.Context, v interface{}) (*model.ChatCompletionContentPartImageURLInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputChatCompletionContentPartImageURLInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChatCompletionMessageContent2githubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContent(ctx context.Context, sel ast.SelectionSet, v model.ChatCompletionMessageContent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChatCompletionMessageContent(ctx, sel, v)
}

func (ec *executionContext) unmarshalOChatCompletionMessageContentPartInput2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContentPartInputᚄ(ctx context.Context, v interface{}) ([]*model.ChatCompletionMessageContentPartInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.ChatCompletionMessageContentPartInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChatCompletionMessageContentPartInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageContentPartInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOChatCompletionMessageToolCall2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCallᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ChatCompletionMessageToolCall) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChatCompletionMessageToolCall2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCall(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChatCompletionMessageToolCallChunk2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCallChunkᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ChatCompletionMessageToolCallChunk) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChatCompletionMessageToolCallChunk2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCallChunk(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOChatCompletionMessageToolCallInput2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCallInputᚄ(ctx context.Context, v interface{}) ([]*model.ChatCompletionMessageToolCallInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.ChatCompletionMessageToolCallInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChatCompletionMessageToolCallInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionMessageToolCallInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOChatCompletionTool2ᚕᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionTool(ctx context.Context, v interface{}) ([]*model.ChatCompletionTool, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.ChatCompletionTool, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOChatCompletionTool2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionTool(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOChatCompletionTool2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionTool(ctx context.Context, v interface{}) (*model.ChatCompletionTool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputChatCompletionTool(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOChatCompletionToolChoiceOption2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionToolChoiceOption(ctx context.Context, v interface{}) (*model.ChatCompletionToolChoiceOption, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ChatCompletionToolChoiceOption)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChatCompletionToolChoiceOption2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionToolChoiceOption(ctx context.Context, sel ast.SelectionSet, v *model.ChatCompletionToolChoiceOption) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOChatCompletionToolFunction2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐChatCompletionToolFunction(ctx context.Context, v interface{}) (*model.ChatCompletionToolFunction, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputChatCompletionToolFunction(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateChatCompletionServiceTier2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐCreateChatCompletionServiceTier(ctx context.Context, v interface{}) (*model.CreateChatCompletionServiceTier, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.CreateChatCompletionServiceTier)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCreateChatCompletionServiceTier2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐCreateChatCompletionServiceTier(ctx context.Context, sel ast.SelectionSet, v *model.CreateChatCompletionServiceTier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOCreateChatCompletionStreamOptions2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐCreateChatCompletionStreamOptions(ctx context.Context, v interface{}) (*model.CreateChatCompletionStreamOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateChatCompletionStreamOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFinishReason2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFinishReason(ctx context.Context, v interface{}) (*model.FinishReason, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FinishReason)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFinishReason2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFinishReason(ctx context.Context, sel ast.SelectionSet, v *model.FinishReason) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOFunctionCall2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFunctionCall(ctx context.Context, sel ast.SelectionSet, v *model.FunctionCall) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FunctionCall(ctx, sel, v)
}

func (ec *executionContext) marshalOFunctionCallChunk2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFunctionCallChunk(ctx context.Context, sel ast.SelectionSet, v *model.FunctionCallChunk) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FunctionCallChunk(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFunctionCallInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐFunctionCallInput(ctx context.Context, v interface{}) (*model.FunctionCallInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFunctionCallInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOImageDetail2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐImageDetail(ctx context.Context, v interface{}) (*model.ImageDetail, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ImageDetail)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOImageDetail2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐImageDetail(ctx context.Context, sel ast.SelectionSet, v *model.ImageDetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOJSONSchemaInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐJSONSchemaInput(ctx context.Context, v interface{}) (*model.JSONSchemaInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJSONSchemaInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLogProbs2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐLogProbs(ctx context.Context, sel ast.SelectionSet, v *model.LogProbs) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LogProbs(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalOResponseFormatInput2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐResponseFormatInput(ctx context.Context, v interface{}) (*model.ResponseFormatInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputResponseFormatInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOUsage2ᚖgithubᚗcomᚋlingticioᚋgatewayᚋinternalᚋgraphᚋopenaiᚋmodelᚐUsage(ctx context.Context, sel ast.SelectionSet, v *model.Usage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Usage(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
